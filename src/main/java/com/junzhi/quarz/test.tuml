@startuml
namespace railgun {
    class BatchConfig << (S,Aquamarine) >> {
        + PreWorker int
        + PreBuffer int
        + BatchWorker int
        + BatchBuffer int
        + BatchSize int
        + BatchInterval time.Duration
        + Attempts int
        + Backoff *netutil.BackoffConfig
        + BatchType string

        - fix() 

    }
    class BatchProcessor << (S,Aquamarine) >> {
        - unpack BatchUnpackFunc
        - preDo BatchPreDoFunc
        - batchDo BatchDoFunc
        - preChans []<font color=blue>chan</font> *batchMessage
        - batchChans []<font color=blue>chan</font> *batchMessage
        - config *BatchConfig
        - preWait sync.WaitGroup
        - batchWait sync.WaitGroup
        - name string
        - errHandler BatchErrHandler
        - preCommit bool
        - hotSpot *batchHotSpot

        - start() 
        - add(msg PrivateMessage) 
        - addPre(unpacks []BatchUnpackMsg, msg PrivateMessage) 
        - addBatch(msg *batchMessage) 
        - close() 
        - batchPreproc(index int, ch <font color=blue>chan</font> *batchMessage) 
        - batchproc(index int, ch <font color=blue>chan</font> *batchMessage) 
        - setName(name string) 
        - handleErr(ctx context.Context, step BatchStep, msgs ...Message) 

    }
    class BatchUnpackMsg << (S,Aquamarine) >> {
        + BatchKey string
        + PreGroup int64
        + BatchGroup int64
        + Item <font color=blue>interface</font>{}

    }
    class Config << (S,Aquamarine) >> {
        + QuotaID string

    }
    class CronInputer << (S,Aquamarine) >> {
        - name string
        - ch <font color=blue>chan</font> PrivateMessage
        - cron *cron.Cron
        - spec string
        - ctx context.Context
        - cancel <font color=blue>func</font>() 

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - start() 
        - close() 

    }
    class CronInputerConfig << (S,Aquamarine) >> {
        + Spec string

    }
    class CronProcessor << (S,Aquamarine) >> {
        - do CronDoFunc
        - ch <font color=blue>chan</font> PrivateMessage
        - config *CronProcessorConfig
        - wait sync.WaitGroup
        - name string
        - parallel bool
        - uniq *RedisLock
        - redisLockOptions []RedisLockOption

        - start() 
        - add(msg PrivateMessage) 
        - close() 
        - cronDoproc() 
        - cronDo(m PrivateMessage) 
        - run(ctx context.Context, m PrivateMessage) 
        - setName(name string) 

    }
    class CronProcessorConfig << (S,Aquamarine) >> {
        + Parallel bool
        + Attempts int
        + Backoff *netutil.BackoffConfig

        - fix() 

    }
    class CronUniqConfig << (S,Aquamarine) >> {
    }
    class DatabusV1Config << (S,Aquamarine) >> {
        - fix() 

    }
    class DatabusV1Inputer << (S,Aquamarine) >> {
        - name string
        - databus *databus.Databus
        - ch <font color=blue>chan</font> PrivateMessage
        - head *databusV1Message
        - mu sync.Mutex
        - commitChan <font color=blue>chan</font> <font color=blue>interface</font>{}
        - wg sync.WaitGroup
        - quit <font color=blue>chan</font> <font color=blue>interface</font>{}

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - start() 
        - consumeproc() 
        - commitproc() 
        - commit() 
        - close() 

    }
    class DatabusV2Config << (S,Aquamarine) >> {
        + AppID string
        + Token string
        + Topic string

    }
    class DatabusV2Inputer << (S,Aquamarine) >> {
        - name string
        - consumer databus.v2.Consumer
        - ch <font color=blue>chan</font> PrivateMessage
        - head *databusMessage
        - mu sync.Mutex
        - commitChan <font color=blue>chan</font> <font color=blue>interface</font>{}
        - wg sync.WaitGroup
        - quit <font color=blue>chan</font> <font color=blue>interface</font>{}

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - start() 
        - consumeproc() 
        - commitproc() 
        - commit() 
        - close() 

    }
    interface Inputer  {
        + AwesomeRailgun() 

    }
    class KafkaConfig << (S,Aquamarine) >> {
        + Topic string
        + Group string
        + Brokers []string

    }
    class KafkaInputer << (S,Aquamarine) >> {
        - name string
        - client sarama.Client
        - consumer *sarama-cluster.Consumer
        - ch <font color=blue>chan</font> PrivateMessage
        - head *kafkaMessage
        - mu sync.Mutex
        - commitChan <font color=blue>chan</font> <font color=blue>interface</font>{}
        - wg sync.WaitGroup
        - quit <font color=blue>chan</font> <font color=blue>interface</font>{}
        - cfg *KafkaConfig

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - start() 
        - offsetproc() 
        - refreshOffset() 
        - consumeproc() 
        - commitproc() 
        - commit() 
        - close() 

    }
    class ManualInputer << (S,Aquamarine) >> {
        - name string
        - ch <font color=blue>chan</font> PrivateMessage
        - closed bool

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - manualReceive() <font color=blue>chan</font> PrivateMessage
        - start() 
        - manualSend(ctx context.Context, msg PrivateMessage) error
        - close() 

        + AwesomeRailgun() 
        + Add(ctx context.Context, data []byte) error

    }
    class ManualInputerConfig << (S,Aquamarine) >> {
        + Buffer int

    }
    interface ManualInputerV2  {
        + Add(ctx context.Context, data []byte) error

    }
    interface Message  {
        + Payload() []byte
        + Raw() <font color=blue>interface</font>{}

    }
    class MsgPolicy << (S,Aquamarine) >> {
        + String() string

    }
    interface PrivateInputer  {
        + SetName( string) 
        + Receive() <font color=blue>chan</font> PrivateMessage
        + ManualReceive() <font color=blue>chan</font> PrivateMessage
        + ManualSend(ctx context.Context, msg PrivateMessage) error
        + Start() 
        + Close() 

    }
    interface PrivateMessage  {
        + Ack(err error) 
        + Context() context.Context

    }
    class Railgun << (S,Aquamarine) >> {
        - cfg *Config
        - inputer inputer
        - processor processor
        - waiter quota.Waiter
        - name string
        - consumerGroup sync.WaitGroup
        - lastMsg Message
        - consumeWorker int
        - startOnce *sync.Once
        - closeOnce *sync.Once

        - consumeproc() 

        + BMHandler(ctx *blademaster.Context) 
        + Start() 
        + Close() 

    }
    class RedisLock << (S,Aquamarine) >> {
        - key string
        - redis *redis.Redis
        - millExpire int
        - value string
        - retryInterval time.Duration
        - maxWaitTime time.Duration
        - wait sync.WaitGroup
        - closeChan <font color=blue>chan</font> bool

        + GetLock(ctx context.Context) (bool, error)
        + ReleaseLock(ctx context.Context) error
        + ExpireLock(ctx context.Context) error
        + Close() 
        + Do(ctx context.Context, fn <font color=blue>func</font>(context.Context) error, opts ...RedisLockOption) (bool, error)

    }
    class RedisLockConfig << (S,Aquamarine) >> {
        + Key string
        + KeyExpire time.Duration
        + RetryInterval time.Duration
        + ErrMaxWaitTime time.Duration

    }
    class RemoteCronInputer << (S,Aquamarine) >> {
        - name string
        - ch <font color=blue>chan</font> PrivateMessage
        - client *blademaster.Client
        - ctx context.Context
        - cancel <font color=blue>func</font>() 
        - latestMsgs <font color=blue>map</font>[string]bool
        - latestMsgsList []string
        - latestLock sync.Mutex

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - manualReceive() <font color=blue>chan</font> PrivateMessage
        - removeDupMsg(taskID int64, uuid string) 
        - checkDupMsg(taskID int64, uuid string) bool
        - manualSend(ctx context.Context, msg PrivateMessage) error
        - start() 
        - close() 
        - syncState(info remoteCronExecuteInfo, state taskState, msg string) error
        - sendSyncReq(addr string, info remoteCronExecuteInfo, state taskState, msg string) error

        + AwesomeRailgun() 

    }
    class RemoteCronInputerConfig << (S,Aquamarine) >> {
        + Buffer int

    }
    class ReplaceConfig << (S,Aquamarine) >> {
        + PreWorker int
        + PreBuffer int
        + ReplaceWorker int
        + ReplaceBuffer int
        + ReplaceSize int
        + ReplaceInterval time.Duration
        + Attempts int
        + Backoff *netutil.BackoffConfig

        - fix() 

    }
    class ReplaceProcessor << (S,Aquamarine) >> {
        - unpack ReplaceUnpackFunc
        - preDo ReplacePreDoFunc
        - replaceDo ReplaceDoFunc
        - preChans []<font color=blue>chan</font> *replaceMessage
        - replaceChans []<font color=blue>chan</font> *replaceMessage
        - config *ReplaceConfig
        - preWait sync.WaitGroup
        - replaceWait sync.WaitGroup
        - name string
        - errHandler ReplaceErrHandler
        - processHandler ReplaceProcessHandler
        - preCommit bool
        - hotSpot *replaceHotSpot

        - start() 
        - add(msg PrivateMessage) 
        - addPre(unpacks []ReplaceUnpackMsg, msg PrivateMessage) 
        - addReplace(msg *replaceMessage) 
        - close() 
        - replacePreproc(index int, ch <font color=blue>chan</font> *replaceMessage) 
        - replaceproc(index int, ch <font color=blue>chan</font> *replaceMessage) 
        - setName(name string) 
        - handleErr(ctx context.Context, step ReplaceStep, msgs ...Message) 

    }
    class ReplaceUnpackMsg << (S,Aquamarine) >> {
        + ReplaceKey string
        + PreGroup int64
        + ReplaceGroup int64
        + Item <font color=blue>interface</font>{}

    }
    class SingleConfig << (S,Aquamarine) >> {
        + Worker int
        + Buffer int
        + Attempts int
        + Backoff *netutil.BackoffConfig

        - fix() 

    }
    class SingleProcessor << (S,Aquamarine) >> {
        - unpack SingleUnpackFunc
        - do SingleDoFunc
        - chans []<font color=blue>chan</font> *singleMessage
        - config *SingleConfig
        - wait sync.WaitGroup
        - name string
        - errHandler SingleErrHandler
        - hotSpot *singleHotSpot

        - start() 
        - add(msg PrivateMessage) 
        - addDo(unpack *SingleUnpackMsg, msg PrivateMessage) 
        - close() 
        - singleDoproc(index int, ch <font color=blue>chan</font> *singleMessage) 
        - setName(name string) 
        - handleErr(ctx context.Context, step SingleStep, msg Message) 

    }
    class SingleUnpackMsg << (S,Aquamarine) >> {
        + Group int64
        + Item <font color=blue>interface</font>{}

    }
    class batchHotSpot << (S,Aquamarine) >> {
        - preFunc <font color=blue>func</font>(context.Context, []byte, <font color=blue>interface</font>{}) 
        - batchFunc <font color=blue>func</font>(context.Context, []byte, <font color=blue>interface</font>{}) 
        - pre *hotSpot
        - batch *hotSpot

    }
    class batchMessage << (S,Aquamarine) >> {
        - batchKey string
        - item <font color=blue>interface</font>{}
        - batchGroup int64
        - raw PrivateMessage
        - ctx context.Context
        - tr trace.Trace

    }
    class cronMessage << (S,Aquamarine) >> {
        - cron *CronInputer
        - ctx context.Context
        - trace trace.Trace

        + Ack(err error) 
        + Payload() []byte
        + Raw() <font color=blue>interface</font>{}
        + Context() context.Context

    }
    class databusMessage << (S,Aquamarine) >> {
        - databus *DatabusV2Inputer
        - msg databus.v2.Message
        - next *databusMessage
        - done int32
        - err error
        - ctx context.Context
        - trace trace.Trace
        - ts time.Time

        + Context() context.Context
        + Raw() <font color=blue>interface</font>{}
        + Ack(err error) 
        + Payload() []byte

    }
    class databusV1Message << (S,Aquamarine) >> {
        - databus *DatabusV1Inputer
        - msg *databus.Message
        - next *databusV1Message
        - done int32
        - err error
        - ctx context.Context
        - trace trace.Trace
        - ts time.Time

        + Context() context.Context
        + Raw() <font color=blue>interface</font>{}
        + Ack(err error) 
        + Payload() []byte

    }
    class fanout << (S,Aquamarine) >> {
        - name string
        - ch <font color=blue>chan</font> <font color=blue>func</font>() 
        - ctx context.Context
        - cancel <font color=blue>func</font>() 
        - waiter sync.WaitGroup

        - proc() 

        + Do(f <font color=blue>func</font>() ) error
        + Close() error

    }
    class hotSpot << (S,Aquamarine) >> {
        - maxBlockChan int
        - buffer int
        - chans []<font color=blue>interface</font>{}
        - closed bool
        - interval time.Duration
        - flags []bool
        - fanouts []*fanout
        - name string

        - start(name string) 
        - close() 
        - monitor() 
        - check(idx int64) bool
        - add(idx int64, fn <font color=blue>func</font>() ) error

    }
    interface inputer  {
        - setName( string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - manualReceive() <font color=blue>chan</font> PrivateMessage
        - manualSend(ctx context.Context, msg PrivateMessage) error
        - start() 
        - close() 

    }
    class inputerV2Wrapper << (S,Aquamarine) >> {
        - ipt PrivateInputer

        - setName(name string) 
        - receive() <font color=blue>chan</font> PrivateMessage
        - manualReceive() <font color=blue>chan</font> PrivateMessage
        - manualSend(ctx context.Context, msg PrivateMessage) error
        - start() 
        - close() 

        + AwesomeRailgun() 

    }
    class kafkaMessage << (S,Aquamarine) >> {
        - kafka *KafkaInputer
        - msg *sarama.ConsumerMessage
        - next *kafkaMessage
        - done int32
        - err error
        - ctx context.Context
        - trace trace.Trace

        + Context() context.Context
        + Raw() <font color=blue>interface</font>{}
        + Ack(err error) 
        + Payload() []byte

    }
    class manualInputerV2 << (S,Aquamarine) >> {
        - ipt *ManualInputer

        + AwesomeRailgun() 
        + Add(ctx context.Context, data []byte) error
        + SetName(name string) 
        + Receive() <font color=blue>chan</font> PrivateMessage
        + ManualReceive() <font color=blue>chan</font> PrivateMessage
        + ManualSend(ctx context.Context, msg PrivateMessage) error
        + Start() 
        + Close() 

    }
    class manualMessage << (S,Aquamarine) >> {
        - d *ManualInputer

        + Ack(err error) 

    }
    class message << (S,Aquamarine) >> {
        - data []byte
        - trace trace.Trace
        - ctx context.Context
        - err error

        + Ack(err error) 
        + Payload() []byte
        + Raw() <font color=blue>interface</font>{}
        + Context() context.Context

    }
    class oidBatch << (S,Aquamarine) >> {
        - msgs []*batchMessage
        - lastUpdate *time.Time

    }
    class options << (S,Aquamarine) >> {
        - retainLock bool

    }
    interface processor  {
        - setName( string) 
        - add(msg PrivateMessage) 
        - start() 
        - close() 

    }
    class railgun.BatchDoFunc << (T, #FF7700) >>  {
    }
    class railgun.BatchErrHandler << (T, #FF7700) >>  {
    }
    class railgun.BatchKey << (T, #FF7700) >>  {
    }
    class railgun.BatchPreDoFunc << (T, #FF7700) >>  {
    }
    class railgun.BatchStep << (T, #FF7700) >>  {
    }
    class railgun.BatchUnpackFunc << (T, #FF7700) >>  {
    }
    class railgun.CronDoFunc << (T, #FF7700) >>  {
    }
    class railgun.MsgPolicy << (T, #FF7700) >>  {
    }
    class railgun.RedisLockOption << (T, #FF7700) >>  {
    }
    class railgun.ReplaceDoFunc << (T, #FF7700) >>  {
    }
    class railgun.ReplaceErrHandler << (T, #FF7700) >>  {
    }
    class railgun.ReplaceKey << (T, #FF7700) >>  {
    }
    class railgun.ReplacePreDoFunc << (T, #FF7700) >>  {
    }
    class railgun.ReplaceProcessHandler << (T, #FF7700) >>  {
    }
    class railgun.ReplaceStep << (T, #FF7700) >>  {
    }
    class railgun.ReplaceUnpackFunc << (T, #FF7700) >>  {
    }
    class railgun.SingleDoFunc << (T, #FF7700) >>  {
    }
    class railgun.SingleErrHandler << (T, #FF7700) >>  {
    }
    class railgun.SingleStep << (T, #FF7700) >>  {
    }
    class railgun.SingleUnpackFunc << (T, #FF7700) >>  {
    }
    class railgun.taskState << (T, #FF7700) >>  {
    }
    class remoteCronExecuteInfo << (S,Aquamarine) >> {
        + TaskID int64
        + UUID string
        + Heartbeat int64
        + Test bool
        + Addr string

    }
    class remoteCronMessage << (S,Aquamarine) >> {
        - payload []byte
        - info remoteCronExecuteInfo
        - ctx context.Context
        - trace trace.Trace
        - inputer *RemoteCronInputer
        - noticeChan <font color=blue>chan</font> error
        - running bool

        + Ack(err error) 
        + Payload() []byte
        + Raw() <font color=blue>interface</font>{}
        + Context() context.Context

    }
    class replaceHotSpot << (S,Aquamarine) >> {
        - preFunc <font color=blue>func</font>(context.Context, []byte, <font color=blue>interface</font>{}) 
        - replaceFunc <font color=blue>func</font>(context.Context, []byte, <font color=blue>interface</font>{}) 
        - pre *hotSpot
        - replace *hotSpot

    }
    class replaceMessage << (S,Aquamarine) >> {
        - replaceKey string
        - item <font color=blue>interface</font>{}
        - replaceGroup int64
        - raw PrivateMessage
        - ctx context.Context
        - tr trace.Trace

    }
    class singleHotSpot << (S,Aquamarine) >> {
        - fn <font color=blue>func</font>(context.Context, []byte, <font color=blue>interface</font>{}) 
        - h *hotSpot

    }
    class singleMessage << (S,Aquamarine) >> {
        - item <font color=blue>interface</font>{}
        - group int64
        - raw PrivateMessage
        - ctx context.Context

    }
    class syncMessage << (S,Aquamarine) >> {
        - done <font color=blue>chan</font> <font color=blue>interface</font>{}

        + Ack(err error) 
        + Wait() error

    }
@enduml
